# 面试

# const 指针常量、常量指针

**不考虑类的情况**

const常量在定义时必须初始化，之后⽆法更改

const形参可以接收const和⾮const类型的实参，例如// i 可以是 int 型或者 const int 型void

fun(const int& i){ //...}

**考虑类的情况**

const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进⾏初始化，并且必须有构造函数；

不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化

const成员函数：const对象不可以调⽤⾮const成员函数；⾮const对象都可以调⽤；

不可以改变⾮mutable（⽤该关键字声明的变量可以在const成员函数中被修改）数据的值

补充⼀点const相关：

const修饰变量是也与static有⼀样的隐藏作⽤。

只能在该⽂件中使⽤，其他⽂件不可以引⽤声明使⽤。

因此在头⽂件中声明const变量是没问题的，因为即使被多个⽂件包含，链接性都是内部的，不会出现符号冲突。


# 状态码

# http1.0、1.1、2.0、3.0

# 左右值

**左值：**

表示的是**可以获取地址的表达式**，它能出现在赋值语句的左边，对该表达式进⾏赋值。

但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进⾏赋值

**右值：**

表示⽆法获取地址的对象，有常量值、函数返回值、lambda表达式等。

⽆法获取地址，但不表示其不可改变，当定义了右值的右值引⽤时就可以更改右值。


# 虚拟内存

# 内存泄漏

定义

防止

# 智能指针

shared 原子操作

# cast

# 开源库

# 线程锁ThreadLock




# 笔试

#　MySQL删除数据库

```sql
DROP DATABASE [ IF EXISTS ] <数据库名>
```


<数据库名>：指定要删除的数据库名。
IF EXISTS：用于防止当数据库不存在时发生错误。
DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。

# 以下关于线程池说法不正确的是

**线程池中提交任务方法只有一种：执行summit()方法**

**这个说法是不正确的。**

Java线程池提供了多种提交任务的方法，包括submit()和execute()。

submit()方法可以提交实现了Callable或Runnable接口的任务，并且可以返回一个表示任务的未来结果的Future对象。

而execute()方法则用于提交Runnable任务，但不返回任何结果。


**相比于其他创建线程池的方式，CacheThreadPool最容易产生内存溢出**

CachedThreadPool会为每个提交的任务创建一个线程，

如果大量任务被提交到这种类型的线程池，而且每个任务执行的时间很短，

则可能会创建大量线程，从而可能导致内存溢出或者系统性能下降。

**ScheduledThreadPoolExecutor比Timer更安全**

ScheduledThreadPoolExecutor比Timer更健壮和灵活。

Timer在执行定时任务时只使用单一后台线程，如果一个任务抛出未检查的异常，

那么Timer线程会终止，并且已经安排但尚未执行的任务也不会再执行。

而ScheduledThreadPoolExecutor可以配置多个线程，并且能更好地处理其中一个任务执行中出现的异常。

**Java通过Executor创建线程池**

在Java中，可以通过java.util.concurrent.Executor接口及其子接口ExecutorService来创建和管理线程池。

Executors类提供了多种静态方法来创建不同类型的线程池，例如newFixedThreadPool(), newCachedThreadPool(), newSingleThreadExecutor(), 等等。

# 段表、逻辑地址->物理地址

如以下段表所示，请将逻辑地址（0,125），（1,4096），（2,3800），（6,350）转换成物理地址。

![alt text](0612腾讯云智笔试/image.png)

（0,125）：0<=4,125<=10k,所以物理地址为：50*1024+125

（1,4096）：1<=4,但4096>3k,越界中断

（2,3800）：2<=4,3600<=5k,所以物理地址为：70*1024+3800

（6,350）：因为6>4,越界中断

# Java类加载器说法正确的是

**引导类加载器与拓展类加载器均由C++编写**

在Java中，引导类加载器（Bootstrap ClassLoader）是用C++实现的，它是JVM实现的一部分。

它负责加载Java的核心库（如rt.jar里的类）。拓展类加载器（Extension ClassLoader）也是由C++编写的，用于加载Java平台的扩展库。

**Java中String类由类加载器加载**

Java中的String类，像其他所有的Java类一样，也是由类加载器加载的。具体来说，它是由引导类加载器加载的，因为它是Java核心库的一部分。

**系统类加载器的实现AppClassLoader父类为ClassLoader**

在Java中，系统类加载器（System ClassLoader），通常实现为AppClassLoader，确实是ClassLoader类的一个子类。

AppClassLoader的父类是URLClassLoader，而URLClassLoader的父类则是ClassLoader。

**自定义类加载器需要继承系统类加载器AppClassLoader**

**错误。**

自定义类加载器并不需要继承AppClassLoader。

自定义类加载器通常是通过继承ClassLoader类或者URLClassLoader类（这取决于你的具体需求）来实现的。

AppClassLoader是Java中默认的系统类加载器，用于从应用程序类路径中加载类，但自定义类加载器的创建并不限制于继承AppClassLoader。

# 影响请求分页系统有效（平均）访存时间的因素有？

**磁盘读写时间**

当发生缺页时，系统必须从磁盘读取所需的页面。

磁盘读写操作的时间远长于内存访问时间，是影响有效访存时间的一个重要因素。

磁盘的速度和性能直接影响页面调入和替换的速度。

**缺页率**

缺页率是指访问的页面不在内存中，从而引起页面错误的概率。

缺页率高意味着更频繁地从磁盘加载页面，这会显著增加平均访存时间。

**执行缺页处理程序的CPU时间**

当发生页面错误时，操作系统必须执行缺页处理程序，

这通常包括在磁盘上查找所需页面、可能的页面替换算法执行、从磁盘读取页面以及更新页面表等操作。

这些步骤都需要CPU时间，从而影响总的访存时间。

**内存访问时间**

这是指访问内存中已经加载的数据所需的时间。

内存访问速度通常远高于磁盘访问速度，因此，这部分时间相对较短。

# C++11新特性消除两个对象交互时不必要的对象拷贝，节省运算存储资源

# 路由控制

路由器根据控制表转发数据

**静态路由、动态路由只能选一种使用**

静态路由和动态路由并不是互斥的，它们可以在同一个网络中共存

动态路由根据路由协议交换路由信息

# 代码

```cpp
int a[3][4];
for(int i = 0; i < 3; i++){
    for(int j = 0; j < 4; j++){
        a[i][j] = j;
    }
}
for(auto &row : a){
    for(auto rol : row){
        cout << rol << endl;
    }
}
/*
这个循环中的auto &row : a意味着row是对数组a中的每一行（本质上是一个内部数组）的引用。
因此，这种方式没有进行任何复制操作，直接操作的是原始数组a中的数据。
内部的auto rol : row则是对每行中的每个元素值进行复制，但由于这里只是读取数据并输出，所以不影响性能或结果。
*/
for(auto row : a){
    for(auto rol : row){
        cout << rol << endl;
    }
}
/*
在这个循环中，auto row : a导致row是数组a中每一行的复制版本，而不是引用。
这意味着每次迭代都会创建一个新的数组row，包含原数组对应行的数据的副本。
内部循环同样是对row中每个元素的值进行复制。
虽然这种方式在读取和输出数据时不会影响结果，但它会增加额外的内存复制开销，
尤其是当数组较大时，这可能会影响程序的性能。
*/
```